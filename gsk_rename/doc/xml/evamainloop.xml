<refentry id="EvaMainLoop">
<refmeta>
<refentrytitle role="top_of_page" id="EvaMainLoop.top_of_page">Main Loop (Generic Event Management)</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>EVA Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>Main Loop (Generic Event Management)</refname>
<refpurpose>Convenient way to be notified when certain types of event occur.</refpurpose>
</refnamediv>

<refsynopsisdiv id="EvaMainLoop.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>
                    <link linkend="EvaMainLoopChange">EvaMainLoopChange</link>;
                    <link linkend="EvaMainLoopEvent">EvaMainLoopEvent</link>;
                    <link linkend="EvaMainLoopWaitInfo">EvaMainLoopWaitInfo</link>;
                    <link linkend="EvaSource">EvaSource</link>;
                    <link linkend="EvaMainLoopContextList">EvaMainLoopContextList</link>;
enum                <link linkend="EvaMainLoopEventType">EvaMainLoopEventType</link>;
                    <link linkend="EvaMainLoopClass">EvaMainLoopClass</link>;
                    <link linkend="EvaMainLoop-struct">EvaMainLoop</link>;
<link linkend="void">void</link>                (<link linkend="EvaMainLoopWaitPidFunc">*EvaMainLoopWaitPidFunc</link>)           (<link linkend="EvaMainLoopWaitInfo">EvaMainLoopWaitInfo</link> *info,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="gboolean">gboolean</link>            (<link linkend="EvaMainLoopIdleFunc">*EvaMainLoopIdleFunc</link>)              (<link linkend="gpointer">gpointer</link> user_data);
<link linkend="gboolean">gboolean</link>            (<link linkend="EvaMainLoopSignalFunc">*EvaMainLoopSignalFunc</link>)            (<link linkend="int">int</link> sig_no,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="gboolean">gboolean</link>            (<link linkend="EvaMainLoopTimeoutFunc">*EvaMainLoopTimeoutFunc</link>)           (<link linkend="gpointer">gpointer</link> user_data);
<link linkend="gboolean">gboolean</link>            (<link linkend="EvaMainLoopIOFunc">*EvaMainLoopIOFunc</link>)                (<link linkend="int">int</link> fd,
                                                         <link linkend="GIOCondition">GIOCondition</link> condition,
                                                         <link linkend="gpointer">gpointer</link> user_data);
enum                <link linkend="EvaMainLoopCreateFlags">EvaMainLoopCreateFlags</link>;
<link linkend="EvaMainLoop">EvaMainLoop</link> *       <link linkend="eva-main-loop-new">eva_main_loop_new</link>                   (<link linkend="EvaMainLoopCreateFlags">EvaMainLoopCreateFlags</link> create_flags);
<link linkend="EvaMainLoop">EvaMainLoop</link> *       <link linkend="eva-main-loop-default">eva_main_loop_default</link>               (void);
<link linkend="guint">guint</link>               <link linkend="eva-main-loop-run">eva_main_loop_run</link>                   (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="gint">gint</link> timeout,
                                                         <link linkend="guint">guint</link> *t_waited_out);
<link linkend="EvaSource">EvaSource</link> *         <link linkend="eva-main-loop-add-idle">eva_main_loop_add_idle</link>              (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="EvaMainLoopIdleFunc">EvaMainLoopIdleFunc</link> source_func,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);
<link linkend="EvaSource">EvaSource</link> *         <link linkend="eva-main-loop-add-signal">eva_main_loop_add_signal</link>            (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="int">int</link> signal_number,
                                                         <link linkend="EvaMainLoopSignalFunc">EvaMainLoopSignalFunc</link> signal_func,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);
<link linkend="EvaSource">EvaSource</link> *         <link linkend="eva-main-loop-add-waitpid">eva_main_loop_add_waitpid</link>           (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="int">int</link> process_id,
                                                         <link linkend="EvaMainLoopWaitPidFunc">EvaMainLoopWaitPidFunc</link> waitpid_func,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);
<link linkend="EvaSource">EvaSource</link> *         <link linkend="eva-main-loop-add-io">eva_main_loop_add_io</link>                (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="int">int</link> fd,
                                                         <link linkend="guint">guint</link> events,
                                                         <link linkend="EvaMainLoopIOFunc">EvaMainLoopIOFunc</link> io_func,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);
<link linkend="void">void</link>                <link linkend="eva-source-adjust-io">eva_source_adjust_io</link>                (<link linkend="EvaSource">EvaSource</link> *source,
                                                         <link linkend="guint">guint</link> events);
<link linkend="void">void</link>                <link linkend="eva-source-remove-io-events">eva_source_remove_io_events</link>         (<link linkend="EvaSource">EvaSource</link> *source,
                                                         <link linkend="guint">guint</link> events);
<link linkend="void">void</link>                <link linkend="eva-source-add-io-events">eva_source_add_io_events</link>            (<link linkend="EvaSource">EvaSource</link> *source,
                                                         <link linkend="guint">guint</link> events);
<link linkend="EvaSource">EvaSource</link> *         <link linkend="eva-main-loop-add-timer">eva_main_loop_add_timer</link>             (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="EvaMainLoopTimeoutFunc">EvaMainLoopTimeoutFunc</link> timer_func,
                                                         <link linkend="gpointer">gpointer</link> timer_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> timer_destroy,
                                                         <link linkend="gint64">gint64</link> millis_expire,
                                                         <link linkend="gint64">gint64</link> milli_period);
<link linkend="EvaSource">EvaSource</link> *         <link linkend="eva-main-loop-add-timer-absolute">eva_main_loop_add_timer_absolute</link>    (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="EvaMainLoopTimeoutFunc">EvaMainLoopTimeoutFunc</link> timer_func,
                                                         <link linkend="gpointer">gpointer</link> timer_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> timer_destroy,
                                                         <link linkend="int">int</link> unixtime,
                                                         <link linkend="int">int</link> unixtime_micro);
<link linkend="void">void</link>                <link linkend="eva-source-adjust-timer">eva_source_adjust_timer</link>             (<link linkend="EvaSource">EvaSource</link> *timer_source,
                                                         <link linkend="gint64">gint64</link> millis_expire,
                                                         <link linkend="gint64">gint64</link> milli_period);
<link linkend="void">void</link>                <link linkend="eva-source-remove">eva_source_remove</link>                   (<link linkend="EvaSource">EvaSource</link> *source);
<link linkend="void">void</link>                <link linkend="eva-main-loop-add-context">eva_main_loop_add_context</link>           (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="GMainContext">GMainContext</link> *context);
<link linkend="void">void</link>                <link linkend="eva-main-loop-quit">eva_main_loop_quit</link>                  (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop);
<link linkend="gboolean">gboolean</link>            <link linkend="eva-main-loop-should-continue">eva_main_loop_should_continue</link>       (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop);
<link linkend="EvaMainLoop">EvaMainLoop</link> *       <link linkend="eva-source-peek-main-loop">eva_source_peek_main_loop</link>           (<link linkend="EvaSource">EvaSource</link> *source);
<link linkend="void">void</link>                <link linkend="eva-main-loop-destroy-all-sources">eva_main_loop_destroy_all_sources</link>   (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop);
<link linkend="gboolean">gboolean</link>            <link linkend="eva-main-loop-do-waitpid">eva_main_loop_do_waitpid</link>            (<link linkend="int">int</link> pid,
                                                         <link linkend="EvaMainLoopWaitInfo">EvaMainLoopWaitInfo</link> *wait_info);
</synopsis>
</refsynopsisdiv>

<refsect1 id="EvaMainLoop.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>
  <link linkend="GObject">GObject</link>
   +----EvaMainLoop
         +----<link linkend="EvaMainLoopPollBase">EvaMainLoopPollBase</link>
         +----<link linkend="EvaMainLoopKqueue">EvaMainLoopKqueue</link>
</synopsis>
</refsect1>








<refsect1 id="EvaMainLoop.description" role="desc">
<title role="desc.title">Description</title>
<para>
A main loop is an object which can trap events and call user functions
when those events happen.
</para>
<para>
The events that our main loop handles are fixed:  file-descriptors being
readied, signals being delivered, timeouts, idle functions and child-process
termination are the currently known events.
</para>
<para>
EvaMainLoop itself is abstract, you must use a system-specific derived class
to do polling.  Use <link linkend="eva-main-loop-default"><function>eva_main_loop_default()</function></link> to get a main loop which is
appropriate to your system.
</para>
</refsect1>

<refsect1 id="EvaMainLoop.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="EvaMainLoopChange" role="struct">
<title>EvaMainLoopChange</title>
<indexterm zone="EvaMainLoopChange"><primary sortas="EvaMainLoopChange">EvaMainLoopChange</primary></indexterm><programlisting>typedef struct {
  EvaMainLoopEventType type;
  union
  {
    struct {
      guint number;
      gboolean add;
    } signal;
    struct {
      guint fd;
      GIOCondition old_events;
      GIOCondition events;
    } io;
    struct {
      gint pid;
      gboolean add;
      gboolean did_exit;
    } process;
  } data;
} EvaMainLoopChange;
</programlisting>
<para>
This structure is passed to the system-dependent polling
mechanism to indicate a change in events we want notification of.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="EvaMainLoopEventType">EvaMainLoopEventType</link>&#160;<structfield>type</structfield>;</term>
<listitem><simpara>what type of change is to occur.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopEvent" role="struct">
<title>EvaMainLoopEvent</title>
<indexterm zone="EvaMainLoopEvent"><primary sortas="EvaMainLoopEvent">EvaMainLoopEvent</primary></indexterm><programlisting>typedef struct {
  EvaMainLoopEventType type;
  union
  {
    guint signal;
    struct {
      guint fd;
      GIOCondition events;
    } io;
    EvaMainLoopWaitInfo process_wait_info;
  } data;
} EvaMainLoopEvent;
</programlisting>
<para>
An event passed back from the system-dependent polling
mechanism.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="EvaMainLoopEventType">EvaMainLoopEventType</link>&#160;<structfield>type</structfield>;</term>
<listitem><simpara>what type of event occurred.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EvaMainLoopWaitInfo">EvaMainLoopWaitInfo</link>&#160;<structfield>process_wait_info</structfield>;</term>
<listitem><simpara>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopWaitInfo" role="struct">
<title>EvaMainLoopWaitInfo</title>
<indexterm zone="EvaMainLoopWaitInfo"><primary sortas="EvaMainLoopWaitInfo">EvaMainLoopWaitInfo</primary></indexterm><programlisting>typedef struct {
  int               pid; 
  gboolean          exited;         /* exit(2) or killed by signal? */
  union {
    int             signal;         /* !exited */
    int             exit_status;    /*  exited */
  } d;           
  gboolean          dumped_core;
} EvaMainLoopWaitInfo;
</programlisting>
<para>
Information about a process's termination.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="int">int</link>&#160;<structfield>pid</structfield>;</term>
<listitem><simpara>the process-id which terminated.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gboolean">gboolean</link>&#160;<structfield>exited</structfield>;</term>
<listitem><simpara>whether the process exited, versus being killed
by a signal, including crashes, which exit with SIGSEGV, SIGABRT, etc.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gboolean">gboolean</link>&#160;<structfield>dumped_core</structfield>;</term>
<listitem><simpara>whether the process dumped core.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaSource" role="struct">
<title>EvaSource</title>
<indexterm zone="EvaSource"><primary sortas="EvaSource">EvaSource</primary></indexterm><programlisting>typedef struct _EvaSource EvaSource;</programlisting>
<para>
An opaque object representing a trap of an event.
</para></refsect2>
<refsect2 id="EvaMainLoopContextList" role="struct">
<title>EvaMainLoopContextList</title>
<indexterm zone="EvaMainLoopContextList"><primary sortas="EvaMainLoopContextList">EvaMainLoopContextList</primary></indexterm><programlisting>typedef struct _EvaMainLoopContextList EvaMainLoopContextList;</programlisting>
<para>
Private.
</para></refsect2>
<refsect2 id="EvaMainLoopEventType" role="enum">
<title>enum EvaMainLoopEventType</title>
<indexterm zone="EvaMainLoopEventType"><primary sortas="EvaMainLoopEventType">EvaMainLoopEventType</primary></indexterm><programlisting>typedef enum
{
  EVA_MAIN_LOOP_EVENT_IO,
  EVA_MAIN_LOOP_EVENT_SIGNAL,
  EVA_MAIN_LOOP_EVENT_PROCESS
} EvaMainLoopEventType;
</programlisting>
<para>
Types of event that can be dealt with by this main-loop.
</para><variablelist role="enum">
<varlistentry id="EVA-MAIN-LOOP-EVENT-IO--CAPS" role="constant">
<term><literal>EVA_MAIN_LOOP_EVENT_IO</literal></term>
<listitem><simpara>
An input/output event.  This is really just a file-descriptor event.
</simpara></listitem>
</varlistentry>
<varlistentry id="EVA-MAIN-LOOP-EVENT-SIGNAL--CAPS" role="constant">
<term><literal>EVA_MAIN_LOOP_EVENT_SIGNAL</literal></term>
<listitem><simpara>
</simpara></listitem>
</varlistentry>
<varlistentry id="EVA-MAIN-LOOP-EVENT-PROCESS--CAPS" role="constant">
<term><literal>EVA_MAIN_LOOP_EVENT_PROCESS</literal></term>
<listitem><simpara>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopClass" role="struct">
<title>EvaMainLoopClass</title>
<indexterm zone="EvaMainLoopClass"><primary sortas="EvaMainLoopClass">EvaMainLoopClass</primary></indexterm><programlisting>typedef struct {
  GObjectClass object_class;
  gboolean (*setup)  (EvaMainLoop       *main_loop);
  void     (*change) (EvaMainLoop       *main_loop,
                      EvaMainLoopChange *change);
  guint    (*poll)   (EvaMainLoop       *main_loop,
                      guint              max_events_out,
                      EvaMainLoopEvent  *events,
                      gint               timeout);
} EvaMainLoopClass;
</programlisting>
<para>
The virtual function which must be implemented for each type of main-loop.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GObjectClass">GObjectClass</link>&#160;<structfield>object_class</structfield>;</term>
<listitem><simpara>the base class from which the main-loop is derived.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><structfield>setup</structfield>&#160;()</term>
<listitem><simpara>function to call to initialize the main-loop.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><structfield>change</structfield>&#160;()</term>
<listitem><simpara>function invoked to indicate that a change in events we
are interested in has occurred.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><structfield>poll</structfield>&#160;()</term>
<listitem><simpara>function invoked to check which events have occurred.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoop-struct" role="struct">
<title>EvaMainLoop</title>
<indexterm zone="EvaMainLoop-struct"><primary sortas="EvaMainLoop">EvaMainLoop</primary></indexterm><programlisting>typedef struct {
  gint		 exit_status;

  EvaMainLoopEvent *event_array_cache;
  unsigned       max_events;

  /* a list of GMainContext's */
  EvaMainLoopContextList *first_context;
  EvaMainLoopContextList *last_context;
} EvaMainLoop;
</programlisting>
<para>
A main-loop.  This holds information about all its sources.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="gint">gint</link>&#160;<structfield>exit_status</structfield>;</term>
<listitem><simpara>Stored exit status which the user may
return from <link linkend="main"><function>main()</function></link>.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EvaMainLoopEvent">EvaMainLoopEvent</link>&#160;*<structfield>event_array_cache</structfield>;</term>
<listitem><simpara>
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EvaMainLoopContextList">EvaMainLoopContextList</link>&#160;*<structfield>first_context</structfield>;</term>
<listitem><simpara>first GMainContext in the list.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EvaMainLoopContextList">EvaMainLoopContextList</link>&#160;*<structfield>last_context</structfield>;</term>
<listitem><simpara>last GMainContext in the list.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopWaitPidFunc" role="function">
<title>EvaMainLoopWaitPidFunc ()</title>
<indexterm zone="EvaMainLoopWaitPidFunc"><primary sortas="EvaMainLoopWaitPidFunc">EvaMainLoopWaitPidFunc</primary></indexterm><programlisting><link linkend="void">void</link>                (*EvaMainLoopWaitPidFunc)           (<link linkend="EvaMainLoopWaitInfo">EvaMainLoopWaitInfo</link> *info,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
A function which will be invoked when a process terminates.
</para><variablelist role="params">
<varlistentry><term><parameter>info</parameter>&#160;:</term>
<listitem><simpara>information about the process and why it terminated.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>data registered to <link linkend="eva-main-loop-add-waitpid"><function>eva_main_loop_add_waitpid()</function></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopIdleFunc" role="function">
<title>EvaMainLoopIdleFunc ()</title>
<indexterm zone="EvaMainLoopIdleFunc"><primary sortas="EvaMainLoopIdleFunc">EvaMainLoopIdleFunc</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            (*EvaMainLoopIdleFunc)              (<link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Function to be called repetitively (that is, with no blocking or waiting; however,
other events will continue to be processed).  It will stop when <link linkend="eva-main-loop-remove"><function>eva_main_loop_remove()</function></link>
is run on its source, or if it returns FALSE.
</para><variablelist role="params">
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>data registered to <link linkend="eva-main-loop-add-idle"><function>eva_main_loop_add_idle()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>whether to continue running.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopSignalFunc" role="function">
<title>EvaMainLoopSignalFunc ()</title>
<indexterm zone="EvaMainLoopSignalFunc"><primary sortas="EvaMainLoopSignalFunc">EvaMainLoopSignalFunc</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            (*EvaMainLoopSignalFunc)            (<link linkend="int">int</link> sig_no,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Function to be called whenever a UNIX signal of a particular number is raised.
</para>
<para>
It will be untrapped when <link linkend="eva-main-loop-remove"><function>eva_main_loop_remove()</function></link> is run on its source,
or if it returns FALSE.
</para><variablelist role="params">
<varlistentry><term><parameter>sig_no</parameter>&#160;:</term>
<listitem><simpara>the number of the signal that was raised.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>data registered to <link linkend="eva-main-loop-add-signal"><function>eva_main_loop_add_signal()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>whether to continue trapping the unix signal.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopTimeoutFunc" role="function">
<title>EvaMainLoopTimeoutFunc ()</title>
<indexterm zone="EvaMainLoopTimeoutFunc"><primary sortas="EvaMainLoopTimeoutFunc">EvaMainLoopTimeoutFunc</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            (*EvaMainLoopTimeoutFunc)           (<link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Function to invoke whenever a timeout expires.
</para>
<para>
It will be untrapped when <link linkend="eva-main-loop-remove"><function>eva_main_loop_remove()</function></link> is run on its source,
or if it returns FALSE, or after it runs if it was registered as a one-shot (with
milli_period==-1).
</para><variablelist role="params">
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>data registered to <link linkend="eva-main-loop-add-timer"><function>eva_main_loop_add_timer()</function></link> or
<link linkend="eva-main-loop-add-timer-absolute"><function>eva_main_loop_add_timer_absolute()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>whether to keep running this timer.  (Will be ignored if it is a one-shot timer
or if the source has been destroyed)
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopIOFunc" role="function">
<title>EvaMainLoopIOFunc ()</title>
<indexterm zone="EvaMainLoopIOFunc"><primary sortas="EvaMainLoopIOFunc">EvaMainLoopIOFunc</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            (*EvaMainLoopIOFunc)                (<link linkend="int">int</link> fd,
                                                         <link linkend="GIOCondition">GIOCondition</link> condition,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Function to run whenever some subset of a set of
requested events are noticed.
</para><variablelist role="params">
<varlistentry><term><parameter>fd</parameter>&#160;:</term>
<listitem><simpara>the file-descriptor that the events occured on.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>condition</parameter>&#160;:</term>
<listitem><simpara>the events that triggered the callback.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>data registered to <link linkend="eva-main-loop-add-io"><function>eva_main_loop_add_io()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>whether to keep these source.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="EvaMainLoopCreateFlags" role="enum">
<title>enum EvaMainLoopCreateFlags</title>
<indexterm zone="EvaMainLoopCreateFlags"><primary sortas="EvaMainLoopCreateFlags">EvaMainLoopCreateFlags</primary></indexterm><programlisting>typedef enum
{
  EVA_MAIN_LOOP_NEEDS_THREADS = (1 &lt;&lt; 0)
} EvaMainLoopCreateFlags;
</programlisting>
<para>
Indicate user requirements for the main-loop being constructed.
</para><variablelist role="enum">
<varlistentry id="EVA-MAIN-LOOP-NEEDS-THREADS--CAPS" role="constant">
<term><literal>EVA_MAIN_LOOP_NEEDS_THREADS</literal></term>
<listitem><simpara>
Some main loops (like EvaMainLoopKqueue) don't cooperate with
threads at all!  This flag precludes choosing main-loops
which are have this property.
If you don't need threads, this flag does not hurt, except
that <link linkend="kqueue"><function>kqueue()</function></link> is a pretty good mechanism, so you probably
want to get it right for a high-volume single-threaded server.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-new" role="function">
<title>eva_main_loop_new ()</title>
<indexterm zone="eva-main-loop-new"><primary sortas="eva_main_loop_new">eva_main_loop_new</primary></indexterm><programlisting><link linkend="EvaMainLoop">EvaMainLoop</link> *       eva_main_loop_new                   (<link linkend="EvaMainLoopCreateFlags">EvaMainLoopCreateFlags</link> create_flags);</programlisting>
<para>
Make a new main loop.
</para><variablelist role="params">
<varlistentry><term><parameter>create_flags</parameter>&#160;:</term>
<listitem><simpara>Stipulations on the nature of the main-loop.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>a new main loop.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-default" role="function">
<title>eva_main_loop_default ()</title>
<indexterm zone="eva-main-loop-default"><primary sortas="eva_main_loop_default">eva_main_loop_default</primary></indexterm><programlisting><link linkend="EvaMainLoop">EvaMainLoop</link> *       eva_main_loop_default               (void);</programlisting>
<para>
Get the main-loop which is associated with the current thread.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a pointer to the main-loop.  This function does not
increase the ref-count on the main-loop, so you do not need 
to call <link linkend="g-object-unref"><function>g_object_unref()</function></link> on the return value.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-run" role="function">
<title>eva_main_loop_run ()</title>
<indexterm zone="eva-main-loop-run"><primary sortas="eva_main_loop_run">eva_main_loop_run</primary></indexterm><programlisting><link linkend="guint">guint</link>               eva_main_loop_run                   (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="gint">gint</link> timeout,
                                                         <link linkend="guint">guint</link> *t_waited_out);</programlisting>
<para>
Run the main loop once, for a specified number of milliseconds.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the main loop to run.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout</parameter>&#160;:</term>
<listitem><simpara> the maximum number of milliseconds to run, or -1 for no maximum.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>t_waited_out</parameter>&#160;:</term>
<listitem><simpara> the number of milliseconds out used, if non-NULL.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the number of sources processed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-add-idle" role="function">
<title>eva_main_loop_add_idle ()</title>
<indexterm zone="eva-main-loop-add-idle"><primary sortas="eva_main_loop_add_idle">eva_main_loop_add_idle</primary></indexterm><programlisting><link linkend="EvaSource">EvaSource</link> *         eva_main_loop_add_idle              (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="EvaMainLoopIdleFunc">EvaMainLoopIdleFunc</link> source_func,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);</programlisting>
<para>
This adds an idle function to the main loop.
An idle function is a function which gets called every
time the main loop is run.  Furthermore, while there are
idle functions, the main loop will never block.
</para>
<para>
One popular use of idle functions is to defer
an operation, usually because either something is not
in a good state to call immediately,
or because there may be many requests that should
be handled at one time.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the loop to add the idle function to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>source_func</parameter>&#160;:</term>
<listitem><simpara> the function to call.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> parameter to be passed to <parameter>source_func</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> to be called when the source is destroyed.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="EvaSource"><type>EvaSource</type></link> which can be removed (or ignored).
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-add-signal" role="function">
<title>eva_main_loop_add_signal ()</title>
<indexterm zone="eva-main-loop-add-signal"><primary sortas="eva_main_loop_add_signal">eva_main_loop_add_signal</primary></indexterm><programlisting><link linkend="EvaSource">EvaSource</link> *         eva_main_loop_add_signal            (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="int">int</link> signal_number,
                                                         <link linkend="EvaMainLoopSignalFunc">EvaMainLoopSignalFunc</link> signal_func,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);</programlisting>
<para>
Add a signal handler to the main loop.
</para>
<para>
Please note that unlike a normal unix signal handler (as provided by
signal(2) or sigaction(2)), this handler will be run synchronously,
so you can call non-reentrant methods.
</para>
<para>
Also, because unix signal delivery is unreliable, if the signal is raised a
few times in rapid succession, you may miss some callbacks.
</para>
<para>
It is ok to connect multiple times to a single signal simulataneously.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the loop to add the unix signal handler function to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_number</parameter>&#160;:</term>
<listitem><simpara> the number of the signal handler, like SIGINT.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_func</parameter>&#160;:</term>
<listitem><simpara> the function to run synchronously when a unix signal is raised.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> data to be passed to <parameter>signal_func</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> to be called when the source is destroyed.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="EvaSource"><type>EvaSource</type></link> which can be removed (or ignored).
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-add-waitpid" role="function">
<title>eva_main_loop_add_waitpid ()</title>
<indexterm zone="eva-main-loop-add-waitpid"><primary sortas="eva_main_loop_add_waitpid">eva_main_loop_add_waitpid</primary></indexterm><programlisting><link linkend="EvaSource">EvaSource</link> *         eva_main_loop_add_waitpid           (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="int">int</link> process_id,
                                                         <link linkend="EvaMainLoopWaitPidFunc">EvaMainLoopWaitPidFunc</link> waitpid_func,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);</programlisting>
<para>
Add a handler to trap process termination.
</para>
<para>
Only one handler is allowed per child process.
</para>
<para>
The handler will be invoked synchronously.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the loop to add the child-process termination handler function to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>process_id</parameter>&#160;:</term>
<listitem><simpara> the child's process-id to wait for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>waitpid_func</parameter>&#160;:</term>
<listitem><simpara> function to call when the process terminates in some way or another.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> data to be passed to <parameter>waitpid_func</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> to be called when the source is destroyed.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="EvaSource"><type>EvaSource</type></link> which can be removed (or ignored).
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-add-io" role="function">
<title>eva_main_loop_add_io ()</title>
<indexterm zone="eva-main-loop-add-io"><primary sortas="eva_main_loop_add_io">eva_main_loop_add_io</primary></indexterm><programlisting><link linkend="EvaSource">EvaSource</link> *         eva_main_loop_add_io                (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="int">int</link> fd,
                                                         <link linkend="guint">guint</link> events,
                                                         <link linkend="EvaMainLoopIOFunc">EvaMainLoopIOFunc</link> io_func,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);</programlisting>
<para>
Add a handler to input or output on a file-descriptor (a socket or a pipe, usually).
</para>
<para>
Only one handler trap is allowed per file-descriptor.
</para>
<para>
The handler will be re-invoked until the event subsides.
For example, if you read only part of the data when a input event is raised,
the <parameter>io_func</parameter> will be invoked again at every iteration of the main-loop
until there is no data available.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the loop to add the i/o watch to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>fd</parameter>&#160;:</term>
<listitem><simpara> the file-descriptor to watch for events.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>events</parameter>&#160;:</term>
<listitem><simpara> initial I/O events to watch for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>io_func</parameter>&#160;:</term>
<listitem><simpara> a function to call when the currently requested
events occur.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> data to be passed to <parameter>io_func</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> to be called when the source is destroyed.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="EvaSource"><type>EvaSource</type></link> which can be removed or altered.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-source-adjust-io" role="function">
<title>eva_source_adjust_io ()</title>
<indexterm zone="eva-source-adjust-io"><primary sortas="eva_source_adjust_io">eva_source_adjust_io</primary></indexterm><programlisting><link linkend="void">void</link>                eva_source_adjust_io                (<link linkend="EvaSource">EvaSource</link> *source,
                                                         <link linkend="guint">guint</link> events);</programlisting>
<para>
This changes the types of events being watched by the main-loop.
</para>
<para>
Note:  each new file-descriptor needs a new EvaSource.
You must reuse this EvaSource for a new file-descriptor
even if it happens to have the same numeric value
as a file-descriptor you closed.
(The reason why:  EVA automatically coagulates
multiple adjust_io calls.  This is fine with all main-loops.
However, kqueue(2) on BSD, and possibly others, automatically
unregister all interest in an event if the file-descriptor closes.
Hence, if the file-descriptor is re-opened and re-used with the
same EvaSource, EVA will not be able to determine
that anything has changed, and will not issue a new <link linkend="EvaMainLoopChange"><type>EvaMainLoopChange</type></link>.
This will break main-loops that are sensitive to exact which file-descriptor
(not just the number) was registered.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>source</parameter>&#160;:</term>
<listitem><simpara> the I/O source which now wants to watch different events.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>events</parameter>&#160;:</term>
<listitem><simpara> the new events to watch for the I/O source.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-source-remove-io-events" role="function">
<title>eva_source_remove_io_events ()</title>
<indexterm zone="eva-source-remove-io-events"><primary sortas="eva_source_remove_io_events">eva_source_remove_io_events</primary></indexterm><programlisting><link linkend="void">void</link>                eva_source_remove_io_events         (<link linkend="EvaSource">EvaSource</link> *source,
                                                         <link linkend="guint">guint</link> events);</programlisting>
<para>
Cause this source to stop being notified if any of the events in
the <parameter>events</parameter> parameter are set.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>source</parameter>&#160;:</term>
<listitem><simpara> the input/output source whose events-of-interest set
should be reduced.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>events</parameter>&#160;:</term>
<listitem><simpara> new events which should stop causing <parameter>source</parameter> to wake-up.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-source-add-io-events" role="function">
<title>eva_source_add_io_events ()</title>
<indexterm zone="eva-source-add-io-events"><primary sortas="eva_source_add_io_events">eva_source_add_io_events</primary></indexterm><programlisting><link linkend="void">void</link>                eva_source_add_io_events            (<link linkend="EvaSource">EvaSource</link> *source,
                                                         <link linkend="guint">guint</link> events);</programlisting>
<para>
Cause this source to be notified if any of the events in
the <parameter>events</parameter> parameter are set, in addition to the events which
already caused this source to be woken up.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>source</parameter>&#160;:</term>
<listitem><simpara> the input/output source whose events-of-interest set
should be expanded.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>events</parameter>&#160;:</term>
<listitem><simpara> new events which should cause <parameter>source</parameter> to wake-up.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-add-timer" role="function">
<title>eva_main_loop_add_timer ()</title>
<indexterm zone="eva-main-loop-add-timer"><primary sortas="eva_main_loop_add_timer">eva_main_loop_add_timer</primary></indexterm><programlisting><link linkend="EvaSource">EvaSource</link> *         eva_main_loop_add_timer             (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="EvaMainLoopTimeoutFunc">EvaMainLoopTimeoutFunc</link> timer_func,
                                                         <link linkend="gpointer">gpointer</link> timer_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> timer_destroy,
                                                         <link linkend="gint64">gint64</link> millis_expire,
                                                         <link linkend="gint64">gint64</link> milli_period);</programlisting>
<para>
Add a timeout function to the main-loop.
This is a function that will be called after
a fixed amount of time passes, and then may be called
at a regular interval thereafter.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the main-loop which should keep track and run the timeout.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timer_func</parameter>&#160;:</term>
<listitem><simpara> function to call when the requested amount of time elapses.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timer_data</parameter>&#160;:</term>
<listitem><simpara> data to pass to <parameter>timer_func</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timer_destroy</parameter>&#160;:</term>
<listitem><simpara> optional function to call to destroy the <parameter>timer_data</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>millis_expire</parameter>&#160;:</term>
<listitem><simpara> number of milliseconds to wait before running <parameter>timer_func</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>milli_period</parameter>&#160;:</term>
<listitem><simpara> period between subsequent invocation of the timeout.
This may be -1 to indicate that the timeout is a one-shot.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="EvaSource"><type>EvaSource</type></link> which can be removed or altered.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-add-timer-absolute" role="function">
<title>eva_main_loop_add_timer_absolute ()</title>
<indexterm zone="eva-main-loop-add-timer-absolute"><primary sortas="eva_main_loop_add_timer_absolute">eva_main_loop_add_timer_absolute</primary></indexterm><programlisting><link linkend="EvaSource">EvaSource</link> *         eva_main_loop_add_timer_absolute    (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="EvaMainLoopTimeoutFunc">EvaMainLoopTimeoutFunc</link> timer_func,
                                                         <link linkend="gpointer">gpointer</link> timer_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> timer_destroy,
                                                         <link linkend="int">int</link> unixtime,
                                                         <link linkend="int">int</link> unixtime_micro);</programlisting>
<para>
Add a timeout function to the main-loop.
The <parameter>timer_func</parameter> will be called as soon as we detect that the specified time has passed.
</para>
<para>
The time to wait until is (<parameter>unixtime</parameter> + <parameter>unixtime_micro</parameter> * 10^{-6}) seconds after
New Years, Jan 1, 1970 GMT.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the main-loop which should keep track and run the timeout.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timer_func</parameter>&#160;:</term>
<listitem><simpara> function to call when the requested amount of time elapses.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timer_data</parameter>&#160;:</term>
<listitem><simpara> data to pass to <parameter>timer_func</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timer_destroy</parameter>&#160;:</term>
<listitem><simpara> optional function to call to destroy the <parameter>timer_data</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>unixtime</parameter>&#160;:</term>
<listitem><simpara> number of seconds since Jan 1, 1970 GMT that will have passed when the 
timer should expire.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>unixtime_micro</parameter>&#160;:</term>
<listitem><simpara> fractional part of <parameter>unixtime</parameter>, in microseconds.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="EvaSource"><type>EvaSource</type></link> which can be removed or altered.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-source-adjust-timer" role="function">
<title>eva_source_adjust_timer ()</title>
<indexterm zone="eva-source-adjust-timer"><primary sortas="eva_source_adjust_timer">eva_source_adjust_timer</primary></indexterm><programlisting><link linkend="void">void</link>                eva_source_adjust_timer             (<link linkend="EvaSource">EvaSource</link> *timer_source,
                                                         <link linkend="gint64">gint64</link> millis_expire,
                                                         <link linkend="gint64">gint64</link> milli_period);</programlisting>
<para>
Adjust the timeout and period for an already existing timer source.
(You may only call this on timer sources.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>timer_source</parameter>&#160;:</term>
<listitem><simpara> the timeout source returned by <link linkend="eva-main-loop-add-timer"><function>eva_main_loop_add_timer()</function></link> or <link linkend="eva-main-loop-add-timer-absolute"><function>eva_main_loop_add_timer_absolute()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>millis_expire</parameter>&#160;:</term>
<listitem><simpara> the number of milliseconds from now that the timer should run.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>milli_period</parameter>&#160;:</term>
<listitem><simpara> the period between subsequent runs of the timer, or -1 to indicate that 
the timer is a one-shot.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-source-remove" role="function">
<title>eva_source_remove ()</title>
<indexterm zone="eva-source-remove"><primary sortas="eva_source_remove">eva_source_remove</primary></indexterm><programlisting><link linkend="void">void</link>                eva_source_remove                   (<link linkend="EvaSource">EvaSource</link> *source);</programlisting>
<para>
Destroy a main loop's source.
</para>
<para>
If the source is currently running,
it's destroy method will not be called until the
source's callback returns.  (This way, important data won't be 
deleted unexpectedly in the middle of the user's callback.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>source</parameter>&#160;:</term>
<listitem><simpara> the source to remove and destroy.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-add-context" role="function">
<title>eva_main_loop_add_context ()</title>
<indexterm zone="eva-main-loop-add-context"><primary sortas="eva_main_loop_add_context">eva_main_loop_add_context</primary></indexterm><programlisting><link linkend="void">void</link>                eva_main_loop_add_context           (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop,
                                                         <link linkend="GMainContext">GMainContext</link> *context);</programlisting>
<para>
Indicate that a particular <link linkend="EvaMainLoop"><type>EvaMainLoop</type></link> will take care of
invoking the necessary methods of <parameter>context</parameter>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> main-loop which will take responsibility for <parameter>context</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context</parameter>&#160;:</term>
<listitem><simpara> a GMainContext that should be handled by <link linkend="eva-main-loop-run"><function>eva_main_loop_run()</function></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-quit" role="function">
<title>eva_main_loop_quit ()</title>
<indexterm zone="eva-main-loop-quit"><primary sortas="eva_main_loop_quit">eva_main_loop_quit</primary></indexterm><programlisting><link linkend="void">void</link>                eva_main_loop_quit                  (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop);</programlisting>
<para>
Set the main-loop flag that indicates that it should really stop running.
</para>
<para>
If you are executing a EvaMainLoop using <link linkend="eva-main-loop-run"><function>eva_main_loop_run()</function></link>,
then you should probably check <link linkend="eva-main-loop-should-continue"><function>eva_main_loop_should_continue()</function></link> at every iteration
to ensure that you should not have quit by now.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the main-loop which is being asked to quit.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-should-continue" role="function">
<title>eva_main_loop_should_continue ()</title>
<indexterm zone="eva-main-loop-should-continue"><primary sortas="eva_main_loop_should_continue">eva_main_loop_should_continue</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            eva_main_loop_should_continue       (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop);</programlisting>
<para>
Query whether the main-loop should keep running or not.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara> the main-loop to query.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> whether to keep running this main-loop.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-source-peek-main-loop" role="function">
<title>eva_source_peek_main_loop ()</title>
<indexterm zone="eva-source-peek-main-loop"><primary sortas="eva_source_peek_main_loop">eva_source_peek_main_loop</primary></indexterm><programlisting><link linkend="EvaMainLoop">EvaMainLoop</link> *       eva_source_peek_main_loop           (<link linkend="EvaSource">EvaSource</link> *source);</programlisting>
<para>
Get the main-loop where the source was created.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>source</parameter>&#160;:</term>
<listitem><simpara> the source to query.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the main-loop associated with the source.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-destroy-all-sources" role="function">
<title>eva_main_loop_destroy_all_sources ()</title>
<indexterm zone="eva-main-loop-destroy-all-sources"><primary sortas="eva_main_loop_destroy_all_sources">eva_main_loop_destroy_all_sources</primary></indexterm><programlisting><link linkend="void">void</link>                eva_main_loop_destroy_all_sources   (<link linkend="EvaMainLoop">EvaMainLoop</link> *main_loop);</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>main_loop</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="eva-main-loop-do-waitpid" role="function">
<title>eva_main_loop_do_waitpid ()</title>
<indexterm zone="eva-main-loop-do-waitpid"><primary sortas="eva_main_loop_do_waitpid">eva_main_loop_do_waitpid</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            eva_main_loop_do_waitpid            (<link linkend="int">int</link> pid,
                                                         <link linkend="EvaMainLoopWaitInfo">EvaMainLoopWaitInfo</link> *wait_info);</programlisting>
<para>
Do a waitpid system call on the process and munge the
data into <parameter>wait_info</parameter> for the caller to use.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>pid</parameter>&#160;:</term>
<listitem><simpara> the process id to wait for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>wait_info</parameter>&#160;:</term>
<listitem><simpara> place to collect termination status of the process.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> whether the waitpid succeeded.
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
